<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Noodle!</title>
  <style>
    :root{
      --bg:#05070a; --fg:#e9eef7; --muted:#9fb0c7;
      --btn1:rgba(17,24,39,.88); --btn2:rgba(11,18,32,.88);
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }
    html, body{
      margin:0; padding:0; height:100%;
      background:var(--bg); color:var(--fg);
      overflow:hidden; position:fixed; inset:0;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    #game{
      position:fixed; inset:0; width:100%; height:100%; display:block;
      z-index:1; touch-action:none;
      background:
        radial-gradient(800px 500px at 60% 40%, rgba(60,120,255,.08), transparent 60%),
        radial-gradient(600px 450px at 30% 70%, rgba(0,255,180,.06), transparent 60%),
        #05070a;
    }
    #hud{
      position:fixed; top:0; left:0; right:0; z-index:2;
      padding: calc(10px + var(--safe-top)) calc(12px + var(--safe-right)) 10px calc(12px + var(--safe-left));
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      pointer-events:none;
    }
    #brand{ font-weight:900; letter-spacing:.2px; }
    #hud .stats{
      display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
      font-size:13px; color:var(--muted); font-variant-numeric: tabular-nums;
    }
    .pill{
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(233,238,247,.18);
      background:rgba(17,24,39,.35);
      backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
    }
    .pill b{ color:var(--fg); }

    #controls{
      position:fixed; left:0; right:0; bottom:0; z-index:3;
      padding:10px calc(12px + var(--safe-right)) calc(12px + var(--safe-bottom)) calc(12px + var(--safe-left));
      display:grid; grid-template-columns: 1fr 1fr 1fr 1.2fr; gap:10px;
      background:linear-gradient(180deg, rgba(5,7,10,0), rgba(5,7,10,.55));
      -webkit-backdrop-filter:blur(6px); backdrop-filter:blur(6px);
      touch-action:none;
    }
    .btn{
      -webkit-tap-highlight-color:transparent;
      border:1px solid rgba(233,238,247,.16);
      background:linear-gradient(180deg, var(--btn1), var(--btn2));
      color:var(--fg);
      border-radius:16px;
      padding:14px 10px;
      font-weight:900; letter-spacing:.2px;
      display:flex; align-items:center; justify-content:center; gap:10px;
      min-height:56px;
      touch-action:none;
    }
    .btn .hint{ font-size:12px; font-weight:750; color:var(--muted); }
    .btn.active, .btn:active{
      transform:translateY(1px);
      border-color:rgba(233,238,247,.28);
      box-shadow:0 0 0 3px rgba(120,180,255,.12) inset;
    }
    .btn.shoot.active, .btn.shoot:active{ box-shadow:0 0 0 3px rgba(255,190,120,.12) inset; }

    #overlay{
      position:fixed; inset:0; z-index:4;
      display:grid; place-items:center;
      padding: calc(16px + var(--safe-top)) calc(14px + var(--safe-right)) calc(16px + var(--safe-bottom)) calc(14px + var(--safe-left));
      pointer-events:auto;
      touch-action:manipulation;
    }
    #overlay.hidden{ display:none; }
    .card{
      width:min(520px, calc(100vw - 28px));
      border:1px solid rgba(233,238,247,.18);
      border-radius:22px;
      background:rgba(10,14,22,.72);
      backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
      padding:18px 18px 16px;
      box-shadow:0 18px 60px rgba(0,0,0,.5);
    }
    .card h1{ margin:0 0 8px; font-size:22px; letter-spacing:.2px; }
    .card p{ margin:0 0 12px; color:var(--muted); line-height:1.35; font-size:14px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .card button{
      border:1px solid rgba(233,238,247,.2);
      background:rgba(233,238,247,.08);
      color:var(--fg);
      border-radius:14px;
      padding:10px 12px;
      font-weight:900;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
      cursor:pointer;
    }
    .card button:active{ transform:translateY(1px); }
    .tiny{ margin-top:10px; font-size:12px; color:rgba(233,238,247,.55); }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(233,238,247,.18);
      background:rgba(0,0,0,.25);
      color:rgba(233,238,247,.8);
    }
    @media (max-width:420px){
      #controls{ gap:8px; }
      .btn{ border-radius:14px; min-height:54px; padding:12px 8px; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud" aria-hidden="true">
    <div id="brand">Noodle!</div>
    <div class="stats">
      <span class="pill">Score: <b id="score">0</b></span>
      <span class="pill">Lives: <b id="lives">3</b></span>
      <span class="pill">Wave: <b id="wave">1</b></span>
    </div>
  </div>

  <div id="controls" role="group" aria-label="Game controls">
    <button class="btn" id="leftBtn" aria-label="Rotate Left">◀ <span class="hint">Left</span></button>
    <button class="btn" id="rightBtn" aria-label="Rotate Right">▶ <span class="hint">Right</span></button>
    <button class="btn" id="thrustBtn" aria-label="Thrust">▲ <span class="hint">Thrust</span></button>
    <button class="btn shoot" id="shootBtn" aria-label="Shoot">● <span class="hint">Shoot</span></button>
  </div>

  <div id="overlay">
    <div class="card">
      <h1 id="ovTitle">Noodle!</h1>
      <p id="ovDesc">Tap <b>Start</b>. On iPhone, use the four buttons at the bottom.</p>
      <div class="row">
        <button id="startBtn" type="button">Start</button>
        <button id="resumeBtn" type="button" style="display:none;">Resume</button>
        <button id="restartBtn" type="button" style="display:none;">Restart</button>
      </div>
      <div class="tiny">
        Desktop keys: <span class="kbd">◀</span>/<span class="kbd">▶</span> rotate,
        <span class="kbd">▲</span> thrust, <span class="kbd">Space</span> shoot,
        <span class="kbd">P</span> pause.
      </div>
    </div>
  </div>

<script>
(() => {
  // Prevent rubber-band scrolling for game/controls, but keep overlay taps working.
  document.addEventListener('touchmove', (e) => {
    if (!e.target.closest('#overlay')) e.preventDefault();
  }, { passive: false });

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });

  const hudEl = document.getElementById('hud');
  const controlsEl = document.getElementById('controls');

  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const waveEl  = document.getElementById('wave');

  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovDesc  = document.getElementById('ovDesc');
  const startBtn = document.getElementById('startBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartBtn = document.getElementById('restartBtn');

  const TAU = Math.PI * 2;
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const rand = (a,b)=>a+Math.random()*(b-a);

  let DPR = 1, W = 0, H = 0;
  let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };

  function computeBounds(){
    const hudH = hudEl.getBoundingClientRect().height || 0;
    const ctlH = controlsEl.getBoundingClientRect().height || 0;
    bounds.minX = 0;
    bounds.maxX = W;
    bounds.minY = hudH;
    bounds.maxY = H - ctlH;
    if (bounds.maxY - bounds.minY < 240){
      bounds.minY = 0;
      bounds.maxY = H;
    }
  }

  function resize(){
    const vw = window.visualViewport ? window.visualViewport.width : window.innerWidth;
    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;

    DPR = Math.min(3, Math.max(1, window.devicePixelRatio || 1));
    W = Math.max(320, Math.floor(vw));
    H = Math.max(320, Math.floor(vh));

    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    computeBounds();
    initStars();
  }
  window.addEventListener('resize', resize, { passive: true });
  if (window.visualViewport) window.visualViewport.addEventListener('resize', resize, { passive: true });
  resize();

  // iOS-reliable "tap": fire on touchstart/pointerdown (not click).
  function bindInstantTap(el, fn){
    let lock = false;
    const run = (e) => {
      if (lock) return;
      lock = true;
      if (e && e.preventDefault) e.preventDefault();
      if (e && e.stopPropagation) e.stopPropagation();
      fn();
      setTimeout(() => { lock = false; }, 100);
    };
    el.addEventListener('touchstart', run, { passive: false });
    el.addEventListener('pointerdown', run, { passive: false });
    el.addEventListener('mousedown', run, { passive: false });
    el.addEventListener('click', run, { passive: false });
  }

  const input = { left:false, right:false, thrust:false, shoot:false, paused:false };

  function setBtnActive(btn, v){ btn.classList.toggle('active', v); }

  function bindHold(id, key){
    const btn = document.getElementById(id);
    const down = (e) => { e.preventDefault(); input[key] = true; setBtnActive(btn, true); };
    const up   = (e) => { e.preventDefault(); input[key] = false; setBtnActive(btn, false); };

    btn.addEventListener('touchstart', down, { passive: false });
    btn.addEventListener('touchend', up, { passive: false });
    btn.addEventListener('touchcancel', up, { passive: false });

    btn.addEventListener('pointerdown', down, { passive: false });
    btn.addEventListener('pointerup', up, { passive: false });
    btn.addEventListener('pointercancel', up, { passive: false });
    btn.addEventListener('pointerleave', (e) => { if (e.buttons === 0) up(e); }, { passive: false });
  }

  bindHold('leftBtn', 'left');
  bindHold('rightBtn', 'right');
  bindHold('thrustBtn', 'thrust');
  bindHold('shootBtn', 'shoot');

  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.code === 'ArrowLeft')  input.left = true;
    if (e.code === 'ArrowRight') input.right = true;
    if (e.code === 'ArrowUp')    input.thrust = true;
    if (e.code === 'Space')      input.shoot = true;
    if (e.code === 'KeyP')       togglePause();
  }, { passive: false });

  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft')  input.left = false;
    if (e.code === 'ArrowRight') input.right = false;
    if (e.code === 'ArrowUp')    input.thrust = false;
    if (e.code === 'Space')      input.shoot = false;
  }, { passive: true });

  function wrap(obj){
    const r = obj.r || 0;
    if (obj.x < bounds.minX - r) obj.x = bounds.maxX + r;
    else if (obj.x > bounds.maxX + r) obj.x = bounds.minX - r;
    if (obj.y < bounds.minY - r) obj.y = bounds.maxY + r;
    else if (obj.y > bounds.maxY + r) obj.y = bounds.minY - r;
  }

  const stars = [];
  function initStars(){
    stars.length = 0;
    const n = Math.floor((W * H) / 26000);
    for(let i=0;i<n;i++){
      stars.push({ x: Math.random()*W, y: Math.random()*H, s: rand(0.5,1.8), a: rand(0.12,0.9) });
    }
  }

  const state = {
    running: false, over: false,
    wave: 1, score: 0, lives: 3,
    invuln: 0, shootCooldown: 0,
    bullets: [], shells: [], particles: [],
    lastTime: 0
  };

  const ship = { x: 0, y: 0, vx: 0, vy: 0, a: -Math.PI/2, r: 12, alive: true };

  function drawPastaShell(x, y, r, rot){
    ctx.save(); ctx.translate(x, y); ctx.rotate(rot);
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';

    ctx.strokeStyle = 'rgba(233,238,247,0.90)';
    ctx.lineWidth = Math.max(1, r * 0.08);
    ctx.beginPath();
    const steps = 48;
    for(let i=0;i<=steps;i++){
      const t = (i/steps)*TAU;
      const pinch = 0.78 + 0.22*Math.cos(t);
      const wave  = 1 + 0.06*Math.sin(3*t) + 0.04*Math.sin(7*t);
      const sx = Math.cos(t) * r * 1.05 * wave;
      const sy = Math.sin(t) * r * 0.82 * wave * pinch;
      if (i===0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.stroke();

    ctx.strokeStyle = 'rgba(233,238,247,0.55)';
    ctx.lineWidth = Math.max(1, r * 0.06);
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const t = (i/steps)*TAU;
      const pinch = 0.82 + 0.18*Math.cos(t);
      const wave  = 1 + 0.05*Math.sin(3*t + 0.6) + 0.03*Math.sin(7*t + 0.2);
      const sx = Math.cos(t) * r * 0.72 * wave;
      const sy = Math.sin(t) * r * 0.52 * wave * pinch;
      if (i===0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.stroke();

    ctx.strokeStyle = 'rgba(233,238,247,0.45)';
    ctx.lineWidth = Math.max(1, r * 0.04);
    const ribs = 9;
    for(let i=0;i<ribs;i++){
      const u = (i/(ribs-1))*2 - 1;
      const x0 = u * r * 0.50;
      const y0 = -r*0.05 - (1 - Math.abs(u))*r*0.05;
      const x1 = u * r * 0.78;
      const y1 = r*0.55;
      const cx = u * r * 0.62 + Math.sin(u*2.6)*r*0.08;
      const cy = r*0.18;
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.quadraticCurveTo(cx, cy, x1, y1);
      ctx.stroke();
    }

    ctx.strokeStyle = 'rgba(233,238,247,0.60)';
    ctx.lineWidth = Math.max(1, r * 0.05);
    ctx.beginPath();
    ctx.moveTo(-r*0.35, -r*0.15);
    ctx.quadraticCurveTo(0, -r*0.35, r*0.35, -r*0.15);
    ctx.stroke();

    ctx.restore();
  }

  function shellCollisionRadius(r){ return r * 0.92; }

  function boom(x, y, n, baseSpeed){
    for(let i=0;i<n;i++){
      const a = rand(0, TAU);
      const s = baseSpeed * rand(0.4, 1.0);
      state.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: rand(0.35,0.9), t: 0 });
    }
  }

  function resetShip(){
    ship.x = (bounds.minX + bounds.maxX) / 2;
    ship.y = (bounds.minY + bounds.maxY) / 2;
    ship.vx = 0; ship.vy = 0;
    ship.a = -Math.PI/2;
    ship.r = 12;
    ship.alive = true;
    state.invuln = 2.0;
  }

  function spawnWave(w){
    state.shells.length = 0;
    state.bullets.length = 0;
    state.particles.length = 0;
    resetShip();

    const count = Math.min(4 + w, 10);
    const playW = bounds.maxX - bounds.minX;
    const playH = bounds.maxY - bounds.minY;

    for(let i=0;i<count;i++){
      let x, y;
      for(let tries=0; tries<60; tries++){
        x = bounds.minX + Math.random()*playW;
        y = bounds.minY + Math.random()*playH;
        if (Math.hypot(x-ship.x, y-ship.y) > Math.min(playW,playH)*0.25) break;
      }
      const size = rand(28, 46) * (1 + Math.min(0.6, w*0.03));
      const speed = rand(18, 40) + w*2;
      const ang = rand(0, TAU);
      state.shells.push({
        x, y,
        vx: Math.cos(ang)*speed,
        vy: Math.sin(ang)*speed,
        r: size,
        rot: rand(0, TAU),
        vr: rand(-1.2, 1.2),
        tier: 3
      });
    }
  }

  function shoot(){
    if (state.shootCooldown > 0) return;
    state.shootCooldown = 0.18;
    const speed = 520;
    const bx = ship.x + Math.cos(ship.a)*ship.r*1.2;
    const by = ship.y + Math.sin(ship.a)*ship.r*1.2;
    state.bullets.push({ x: bx, y: by, vx: ship.vx + Math.cos(ship.a)*speed, vy: ship.vy + Math.sin(ship.a)*speed, life: 0.9, r: 2.2 });
  }

  function splitShell(s){
    const tierScore = s.tier === 3 ? 20 : s.tier === 2 ? 50 : 100;
    state.score += tierScore;
    scoreEl.textContent = state.score;
    boom(s.x, s.y, 18, 140);

    if (s.tier <= 1) return;
    const newTier = s.tier - 1;
    const newR = s.r * (newTier === 2 ? 0.62 : 0.48);

    for(let k=0;k<2;k++){
      const ang = rand(0, TAU);
      const sp  = rand(30, 70) + (3 - newTier)*14;
      state.shells.push({
        x: s.x + rand(-6,6),
        y: s.y + rand(-6,6),
        vx: s.vx*0.4 + Math.cos(ang)*sp,
        vy: s.vy*0.4 + Math.sin(ang)*sp,
        r: newR,
        rot: rand(0, TAU),
        vr: rand(-2.0, 2.0),
        tier: newTier
      });
    }
  }

  function killShip(){
    if (state.invuln > 0) return;
    state.lives -= 1;
    livesEl.textContent = state.lives;
    boom(ship.x, ship.y, 26, 160);

    if (state.lives <= 0){
      ship.alive = false;
      state.over = true;
      state.running = false;
      showOverlay('Game Over', `Final score: <b>${state.score}</b>.`, true, false);
      return;
    }
    resetShip();
  }

  function drawStars(){
    ctx.save();
    for(const s of stars){
      ctx.globalAlpha = s.a;
      ctx.fillStyle = 'rgba(233,238,247,0.85)';
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawShip(){
    if (!ship.alive) return;
    if (state.invuln > 0 && Math.floor(state.invuln*10)%2 === 0) return;

    ctx.save(); ctx.translate(ship.x, ship.y); ctx.rotate(ship.a);
    ctx.strokeStyle = 'rgba(233,238,247,0.90)';
    ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(16, 0);
    ctx.lineTo(-12, -9);
    ctx.lineTo(-8, 0);
    ctx.lineTo(-12, 9);
    ctx.closePath();
    ctx.stroke();

    if (input.thrust){
      ctx.strokeStyle = 'rgba(154,255,200,0.75)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(-22 - Math.random()*8, 0);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawBullets(){
    ctx.save();
    ctx.fillStyle = 'rgba(233,238,247,0.95)';
    for(const b of state.bullets){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, TAU);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawParticles(dt){
    ctx.save();
    ctx.strokeStyle = 'rgba(233,238,247,0.55)';
    ctx.lineWidth = 1.5;
    for(const p of state.particles){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = clamp(a, 0, 1);
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x - p.vx*dt*0.06, p.y - p.vy*dt*0.06);
      ctx.stroke();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function clear(){
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.clearRect(0,0,W,H);
    drawStars();
  }

  function showOverlay(title, descHTML, showRestart, showResume){
    ovTitle.textContent = title;
    ovDesc.innerHTML = descHTML;
    overlay.classList.remove('hidden');
    startBtn.style.display = (title === 'Noodle!' && !state.running) ? '' : 'none';
    restartBtn.style.display = showRestart ? '' : 'none';
    resumeBtn.style.display = showResume ? '' : 'none';
  }
  function hideOverlay(){ overlay.classList.add('hidden'); }

  function startGame(){
    resize(); // after first user interaction (iOS Safari bars settle)
    state.running = true;
    state.over = false;
    input.paused = false;
    state.wave = 1;
    state.score = 0;
    state.lives = 3;
    scoreEl.textContent = '0';
    livesEl.textContent = '3';
    waveEl.textContent = '1';
    spawnWave(1);
    hideOverlay();
  }

  function togglePause(){
    if (!state.running || state.over) return;
    input.paused = !input.paused;
    if (input.paused){
      showOverlay('Paused', 'Tap <b>Resume</b> to continue.', true, true);
    } else {
      hideOverlay();
    }
  }

  bindInstantTap(startBtn, startGame);
  bindInstantTap(restartBtn, startGame);
  bindInstantTap(resumeBtn, () => { input.paused = false; hideOverlay(); });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden && state.running && !state.over){
      input.paused = true;
      showOverlay('Paused', 'Game paused when the tab went to the background.', true, true);
    }
  });

  function step(ts){
    requestAnimationFrame(step);
    const t = ts/1000;
    let dt = t - (state.lastTime || t);
    state.lastTime = t;
    dt = clamp(dt, 0, 0.033);

    if (!state.running || input.paused){
      clear();
      for (const s of state.shells) drawPastaShell(s.x, s.y, s.r, s.rot);
      drawBullets();
      drawShip();
      drawParticles(dt);
      return;
    }

    state.shootCooldown = Math.max(0, state.shootCooldown - dt);
    state.invuln = Math.max(0, state.invuln - dt);

    const rotSpeed = 4.8;
    if (input.left)  ship.a -= rotSpeed * dt;
    if (input.right) ship.a += rotSpeed * dt;

    if (input.thrust){
      const accel = 240;
      ship.vx += Math.cos(ship.a) * accel * dt;
      ship.vy += Math.sin(ship.a) * accel * dt;
    }

    const damp = Math.pow(0.42, dt);
    ship.vx *= damp;
    ship.vy *= damp;

    ship.x += ship.vx * dt;
    ship.y += ship.vy * dt;
    wrap(ship);

    if (input.shoot && ship.alive) shoot();

    for (let i = state.bullets.length - 1; i >= 0; i--){
      const b = state.bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;

      if (b.x < bounds.minX - b.r) b.x = bounds.maxX + b.r;
      else if (b.x > bounds.maxX + b.r) b.x = bounds.minX - b.r;
      if (b.y < bounds.minY - b.r) b.y = bounds.maxY + b.r;
      else if (b.y > bounds.maxY + b.r) b.y = bounds.minY - b.r;

      if (b.life <= 0) state.bullets.splice(i, 1);
    }

    for (const s of state.shells){
      s.x += s.vx * dt;
      s.y += s.vy * dt;
      s.rot += s.vr * dt;
      wrap(s);
    }

    for (let i = state.particles.length - 1; i >= 0; i--){
      const p = state.particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.15, dt);
      p.vy *= Math.pow(0.15, dt);
      p.t += dt;
      if (p.t >= p.life) state.particles.splice(i, 1);
    }

    for (let i = state.shells.length - 1; i >= 0; i--){
      const s = state.shells[i];
      const sr = shellCollisionRadius(s.r);
      let hit = -1;
      for (let j = state.bullets.length - 1; j >= 0; j--){
        const bb = state.bullets[j];
        if (Math.hypot(bb.x - s.x, bb.y - s.y) < sr + bb.r){
          hit = j; break;
        }
      }
      if (hit !== -1){
        state.bullets.splice(hit, 1);
        state.shells.splice(i, 1);
        splitShell(s);
      }
    }

    if (ship.alive){
      for (const s of state.shells){
        const sr = shellCollisionRadius(s.r);
        if (Math.hypot(ship.x - s.x, ship.y - s.y) < sr + ship.r*0.9){
          killShip();
          break;
        }
      }
    }

    if (state.shells.length === 0){
      state.wave += 1;
      waveEl.textContent = state.wave;
      spawnWave(state.wave);
    }

    clear();
    for (const s of state.shells) drawPastaShell(s.x, s.y, s.r, s.rot);
    drawBullets();
    drawShip();
    drawParticles(dt);
  }

  showOverlay('Noodle!', 'Tap <b>Start</b>. On iPhone, use the four buttons at the bottom.', true, false);
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
