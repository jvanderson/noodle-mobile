<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Pasta Shells (Asteroids)</title>
  <style>
    :root{
      --bg:#05070a;
      --fg:#e9eef7;
      --muted:#9fb0c7;
      --btn:#111827cc;
      --btn2:#0b1220cc;
      --stroke:rgba(233,238,247,.9);
      --stroke2:rgba(233,238,247,.5);
      --good:#9affc8;
      --bad:#ff8aa3;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }

    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overscroll-behavior: none;
      touch-action: none; /* avoid page scroll/zoom while playing */
    }

    #wrap {
      position: fixed;
      inset: 0;
      padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px 6px;
      user-select: none;
    }

    .hud {
      display: flex;
      align-items: center;
      gap: 14px;
      font-variant-numeric: tabular-nums;
      font-size: 14px;
      color: var(--muted);
    }

    .hud b { color: var(--fg); font-weight: 700; }

    .pill {
      padding: 6px 10px;
      border: 1px solid rgba(233,238,247,.18);
      border-radius: 999px;
      background: rgba(17,24,39,.35);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    .brand {
      display:flex;
      align-items:center;
      gap:10px;
      color: var(--fg);
      font-weight: 750;
      letter-spacing: .2px;
    }
    .brand small{
      color: var(--muted);
      font-weight: 600;
      letter-spacing: .2px;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(800px 500px at 60% 40%, rgba(60,120,255,.08), transparent 60%),
                  radial-gradient(600px 450px at 30% 70%, rgba(0,255,180,.06), transparent 60%),
                  #05070a;
      border-top: 1px solid rgba(233,238,247,.06);
      border-bottom: 1px solid rgba(233,238,247,.06);
    }

    /* Controls */
    footer {
      padding: 10px 12px calc(12px + var(--safe-bottom));
      user-select: none;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1.2fr;
      gap: 10px;
      align-items: stretch;
    }

    .btn {
      -webkit-tap-highlight-color: transparent;
      border: 1px solid rgba(233,238,247,.16);
      background: linear-gradient(180deg, var(--btn), var(--btn2));
      color: var(--fg);
      border-radius: 16px;
      padding: 14px 10px;
      font-weight: 800;
      letter-spacing: .2px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-height: 56px;
      touch-action: none;
      cursor: pointer;
    }

    .btn:active, .btn.active {
      transform: translateY(1px);
      border-color: rgba(233,238,247,.28);
      box-shadow: 0 0 0 3px rgba(120,180,255,.12) inset;
    }

    .btn .hint {
      font-size: 12px;
      font-weight: 700;
      color: var(--muted);
      letter-spacing: .1px;
    }

    .btn.shoot {
      border-color: rgba(233,238,247,.22);
    }

    .btn.shoot:active, .btn.shoot.active {
      box-shadow: 0 0 0 3px rgba(255,190,120,.12) inset;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .card {
      pointer-events: auto;
      max-width: 520px;
      width: min(520px, calc(100vw - 28px));
      border: 1px solid rgba(233,238,247,.18);
      border-radius: 22px;
      background: rgba(10,14,22,.72);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 18px 18px 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,.5);
      text-align: left;
    }
    .card h1 {
      margin: 0 0 6px;
      font-size: 20px;
      letter-spacing: .2px;
    }
    .card p {
      margin: 0 0 12px;
      color: var(--muted);
      line-height: 1.35;
      font-size: 14px;
    }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .card button {
      pointer-events: auto;
      border: 1px solid rgba(233,238,247,.2);
      background: rgba(233,238,247,.08);
      color: var(--fg);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 800;
      cursor: pointer;
    }
    .card button:active {
      transform: translateY(1px);
    }
    .tiny {
      margin-top: 10px;
      font-size: 12px;
      color: rgba(233,238,247,.55);
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(233,238,247,.18);
      background: rgba(0,0,0,.25);
      color: rgba(233,238,247,.8);
    }

    /* Keep controls usable on narrow screens */
    @media (max-width: 420px){
      .controls { gap: 8px; }
      .btn { border-radius: 14px; min-height: 54px; padding: 12px 8px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <div class="brand">
        Pasta Shells <small>(Asteroids)</small>
      </div>
      <div class="hud">
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Lives: <b id="lives">3</b></span>
        <span class="pill">Wave: <b id="wave">1</b></span>
      </div>
    </header>

    <div style="position:relative;">
      <canvas id="c"></canvas>

      <div class="overlay" id="overlay">
        <div class="card">
          <h1 id="title">Pasta Shells</h1>
          <p id="desc">
            Dodge the pasta shells. Shoot them into smaller shells. Clear the wave.
            Mobile controls are below; keyboard also works on desktop.
          </p>
          <div class="row">
            <button id="startBtn">Start</button>
            <button id="resumeBtn" style="display:none;">Resume</button>
            <button id="restartBtn" style="display:none;">Restart</button>
          </div>
          <div class="tiny">
            Controls: <span class="kbd">◀</span>/<span class="kbd">▶</span> rotate,
            <span class="kbd">▲</span> thrust, <span class="kbd">Space</span> shoot,
            <span class="kbd">P</span> pause.
          </div>
        </div>
      </div>
    </div>

    <footer>
      <div class="controls">
        <button class="btn" id="leftBtn" aria-label="Rotate Left">
          ◀ <span class="hint">Left</span>
        </button>
        <button class="btn" id="rightBtn" aria-label="Rotate Right">
          ▶ <span class="hint">Right</span>
        </button>
        <button class="btn" id="thrustBtn" aria-label="Thrust">
          ▲ <span class="hint">Thrust</span>
        </button>
        <button class="btn shoot" id="shootBtn" aria-label="Shoot">
          ● <span class="hint">Shoot</span>
        </button>
      </div>
    </footer>
  </div>

<script>
(() => {
  // ---------- Canvas / DPR ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W = 0, H = 0, DPR = 1;

  function resize() {
    const rect = canvas.getBoundingClientRect();
    DPR = Math.min(3, Math.max(1, window.devicePixelRatio || 1));
    W = Math.max(320, Math.floor(rect.width));
    H = Math.max(320, Math.floor(rect.height));
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // Prevent iOS Safari gestures that can interfere.
  document.addEventListener('gesturestart', (e) => e.preventDefault(), { passive: false });
  document.addEventListener('gesturechange', (e) => e.preventDefault(), { passive: false });
  document.addEventListener('gestureend', (e) => e.preventDefault(), { passive: false });

  // ---------- UI ----------
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const waveEl  = document.getElementById('wave');

  const overlay = document.getElementById('overlay');
  const titleEl = document.getElementById('title');
  const descEl  = document.getElementById('desc');
  const startBtn = document.getElementById('startBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartBtn = document.getElementById('restartBtn');

  // ---------- Input state ----------
  const input = { left:false, right:false, thrust:false, shoot:false, paused:false };
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const thrustBtn = document.getElementById('thrustBtn');
  const shootBtn = document.getElementById('shootBtn');

  function bindHoldButton(btn, onDown, onUp){
    const setActive = (v) => btn.classList.toggle('active', v);

    const down = (e) => {
      e.preventDefault();
      onDown();
      setActive(true);
    };
    const up = (e) => {
      e.preventDefault();
      onUp();
      setActive(false);
    };

    // Pointer events unify touch/mouse.
    btn.addEventListener('pointerdown', down, { passive:false });
    btn.addEventListener('pointerup', up, { passive:false });
    btn.addEventListener('pointercancel', up, { passive:false });
    btn.addEventListener('pointerleave', (e) => { if (e.buttons === 0) up(e); }, { passive:false });
  }

  bindHoldButton(leftBtn,  () => input.left = true,  () => input.left = false);
  bindHoldButton(rightBtn, () => input.right = true, () => input.right = false);
  bindHoldButton(thrustBtn,() => input.thrust = true,() => input.thrust = false);
  bindHoldButton(shootBtn, () => input.shoot = true, () => input.shoot = false);

  // Keyboard (desktop)
  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.code === 'ArrowLeft')  input.left = true;
    if (e.code === 'ArrowRight') input.right = true;
    if (e.code === 'ArrowUp')    input.thrust = true;
    if (e.code === 'Space')      input.shoot = true;
    if (e.code === 'KeyP')       togglePause();
  }, { passive:false });

  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft')  input.left = false;
    if (e.code === 'ArrowRight') input.right = false;
    if (e.code === 'ArrowUp')    input.thrust = false;
    if (e.code === 'Space')      input.shoot = false;
  }, { passive:true });

  // ---------- Math helpers ----------
  const TAU = Math.PI * 2;
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const rand = (a,b)=>a+Math.random()*(b-a);

  function wrap(obj){
    if (obj.x < -obj.r) obj.x = W + obj.r;
    else if (obj.x > W + obj.r) obj.x = -obj.r;
    if (obj.y < -obj.r) obj.y = H + obj.r;
    else if (obj.y > H + obj.r) obj.y = -obj.r;
  }

  // ---------- Game objects ----------
  const state = {
    running:false,
    over:false,
    wave:1,
    score:0,
    lives:3,
    invuln:0,
    bullets:[],
    shells:[],
    particles:[],
    stars:[],
    lastTime:0,
    shootCooldown:0
  };

  const ship = {
    x: W/2, y: H/2,
    vx: 0, vy: 0,
    a: -Math.PI/2,
    r: 12,
    alive:true
  };

  // ---------- Starfield ----------
  function initStars(){
    state.stars = [];
    const n = Math.floor((W*H)/26000);
    for(let i=0;i<n;i++){
      state.stars.push({
        x: Math.random()*W,
        y: Math.random()*H,
        s: rand(0.5,1.8),
        a: rand(0.12,0.9)
      });
    }
  }
  initStars();

  // ---------- Pasta shell (conchiglie) drawing ----------
  function drawPastaShell(x, y, r, rot){
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rot);

    ctx.lineWidth = Math.max(1, r * 0.08);
    ctx.strokeStyle = 'rgba(233,238,247,0.90)';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Outer rim
    ctx.beginPath();
    const steps = 48;
    for(let i=0;i<=steps;i++){
      const t = (i/steps)*TAU;
      const pinch = 0.78 + 0.22*Math.cos(t);
      const wave  = 1 + 0.06*Math.sin(3*t) + 0.04*Math.sin(7*t);
      const sx = Math.cos(t) * r * 1.05 * wave;
      const sy = Math.sin(t) * r * 0.82 * wave * pinch;
      if (i===0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.stroke();

    // Inner rim
    ctx.strokeStyle = 'rgba(233,238,247,0.55)';
    ctx.lineWidth = Math.max(1, r * 0.06);
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const t = (i/steps)*TAU;
      const pinch = 0.82 + 0.18*Math.cos(t);
      const wave  = 1 + 0.05*Math.sin(3*t + 0.6) + 0.03*Math.sin(7*t + 0.2);
      const sx = Math.cos(t) * r * 0.72 * wave;
      const sy = Math.sin(t) * r * 0.52 * wave * pinch;
      if (i===0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.stroke();

    // Ribs
    ctx.strokeStyle = 'rgba(233,238,247,0.45)';
    ctx.lineWidth = Math.max(1, r * 0.04);
    const ribs = 9;
    for(let i=0;i<ribs;i++){
      const u = (i/(ribs-1))*2 - 1;
      const x0 = u * r * 0.50;
      const y0 = -r*0.05 - (1 - Math.abs(u))*r*0.05;
      const x1 = u * r * 0.78;
      const y1 = r*0.55;

      const cx = u * r * 0.62 + Math.sin(u*2.6)*r*0.08;
      const cy = r*0.18;

      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.quadraticCurveTo(cx, cy, x1, y1);
      ctx.stroke();
    }

    // Lip
    ctx.strokeStyle = 'rgba(233,238,247,0.60)';
    ctx.lineWidth = Math.max(1, r * 0.05);
    ctx.beginPath();
    ctx.moveTo(-r*0.35, -r*0.15);
    ctx.quadraticCurveTo(0, -r*0.35, r*0.35, -r*0.15);
    ctx.stroke();

    ctx.restore();
  }

  function shellRadiusForCollision(r){ return r * 0.92; }

  // ---------- Spawning ----------
  function resetShip(){
    ship.x = W/2;
    ship.y = H/2;
    ship.vx = 0; ship.vy = 0;
    ship.a = -Math.PI/2;
    ship.alive = true;
    state.invuln = 2.0;
  }

  function spawnWave(wave){
    state.shells = [];
    state.bullets = [];
    state.particles = [];
    resetShip();

    const count = Math.min(4 + wave, 10);
    for(let i=0;i<count;i++){
      let x,y;
      for(let tries=0; tries<40; tries++){
        x = Math.random()*W;
        y = Math.random()*H;
        if (Math.hypot(x - ship.x, y - ship.y) > Math.min(W,H)*0.25) break;
      }
      const size = rand(28, 46) * (1 + Math.min(0.6, wave*0.03));
      const speed = rand(18, 40) + wave*2;
      const ang = rand(0, TAU);
      state.shells.push({
        x, y,
        vx: Math.cos(ang)*speed,
        vy: Math.sin(ang)*speed,
        r: size,
        rot: rand(0, TAU),
        vr: rand(-1.2, 1.2),
        tier: 3
      });
    }
  }

  // ---------- Particles ----------
  function boom(x,y, n, baseSpeed){
    for(let i=0;i<n;i++){
      const a = rand(0, TAU);
      const s = baseSpeed * rand(0.4, 1.0);
      state.particles.push({
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        life: rand(0.35, 0.9),
        t: 0
      });
    }
  }

  // ---------- Game logic ----------
  function shoot(){
    if (state.shootCooldown > 0) return;
    state.shootCooldown = 0.18;

    const speed = 520;
    const bx = ship.x + Math.cos(ship.a)*ship.r*1.2;
    const by = ship.y + Math.sin(ship.a)*ship.r*1.2;

    state.bullets.push({
      x: bx, y: by,
      vx: ship.vx + Math.cos(ship.a)*speed,
      vy: ship.vy + Math.sin(ship.a)*speed,
      life: 0.9,
      r: 2.2
    });
  }

  function killShip(){
    if (state.invuln > 0) return;
    state.lives -= 1;
    livesEl.textContent = state.lives;
    boom(ship.x, ship.y, 26, 160);

    if (state.lives <= 0){
      ship.alive = false;
      state.over = true;
      state.running = false;
      showOverlay('Game Over', `Final score: <b>${state.score}</b>. Want another round?`, true);
      return;
    }

    resetShip();
  }

  function splitShell(s){
    const tierScore = s.tier === 3 ? 20 : s.tier === 2 ? 50 : 100;
    state.score += tierScore;
    scoreEl.textContent = state.score;

    boom(s.x, s.y, 18, 140);

    if (s.tier <= 1) return;

    const newTier = s.tier - 1;
    const newR = s.r * (newTier === 2 ? 0.62 : 0.48);

    for(let k=0;k<2;k++){
      const ang = rand(0, TAU);
      const sp  = rand(30, 70) + (3 - newTier)*14;
      state.shells.push({
        x: s.x + rand(-6,6),
        y: s.y + rand(-6,6),
        vx: s.vx*0.4 + Math.cos(ang)*sp,
        vy: s.vy*0.4 + Math.sin(ang)*sp,
        r: newR,
        rot: rand(0, TAU),
        vr: rand(-2.0, 2.0),
        tier: newTier
      });
    }
  }

  // ---------- Rendering ----------
  function drawShip(){
    if (!ship.alive) return;
    if (state.invuln > 0 && Math.floor(state.invuln*10)%2 === 0) return;

    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.rotate(ship.a);

    ctx.strokeStyle = 'rgba(233,238,247,0.90)';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(16, 0);
    ctx.lineTo(-12, -9);
    ctx.lineTo(-8, 0);
    ctx.lineTo(-12, 9);
    ctx.closePath();
    ctx.stroke();

    if (input.thrust){
      ctx.strokeStyle = 'rgba(154,255,200,0.75)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(-22 - Math.random()*8, 0);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawBullets(){
    ctx.save();
    ctx.fillStyle = 'rgba(233,238,247,0.95)';
    for(const b of state.bullets){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, TAU);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawShells(){
    for(const s of state.shells){
      drawPastaShell(s.x, s.y, s.r, s.rot);
    }
  }

  function drawParticles(dt){
    ctx.save();
    ctx.strokeStyle = 'rgba(233,238,247,0.55)';
    ctx.lineWidth = 1.5;
    for(const p of state.particles){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = Math.max(0, Math.min(1, a));
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x - p.vx*dt*0.06, p.y - p.vy*dt*0.06);
      ctx.stroke();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawStars(){
    ctx.save();
    for(const s of state.stars){
      ctx.globalAlpha = s.a;
      ctx.fillStyle = 'rgba(233,238,247,0.85)';
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function clear(){
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.clearRect(0,0,W,H);
    drawStars();
  }

  // ---------- Update loop ----------
  function step(t){
    requestAnimationFrame(step);
    const time = t/1000;
    let dt = time - (state.lastTime || time);
    state.lastTime = time;
    dt = Math.max(0, Math.min(0.033, dt));

    if (!state.running || input.paused) {
      clear();
      drawShells();
      drawShip();
      drawBullets();
      drawParticles(dt);
      return;
    }

    state.shootCooldown = Math.max(0, state.shootCooldown - dt);
    state.invuln = Math.max(0, state.invuln - dt);

    const rotSpeed = 4.8;
    if (input.left)  ship.a -= rotSpeed * dt;
    if (input.right) ship.a += rotSpeed * dt;

    if (input.thrust){
      const accel = 240;
      ship.vx += Math.cos(ship.a) * accel * dt;
      ship.vy += Math.sin(ship.a) * accel * dt;
    }

    const damp = Math.pow(0.42, dt);
    ship.vx *= damp;
    ship.vy *= damp;

    ship.x += ship.vx * dt;
    ship.y += ship.vy * dt;
    ship.r = 12;
    wrap(ship);

    if (input.shoot && ship.alive) shoot();

    for (let i = state.bullets.length - 1; i >= 0; i--){
      const b = state.bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;

      if (b.x < -b.r) b.x = W + b.r;
      else if (b.x > W + b.r) b.x = -b.r;
      if (b.y < -b.r) b.y = H + b.r;
      else if (b.y > H + b.r) b.y = -b.r;

      if (b.life <= 0) state.bullets.splice(i, 1);
    }

    for (const s of state.shells){
      s.x += s.vx * dt;
      s.y += s.vy * dt;
      s.rot += s.vr * dt;
      wrap(s);
    }

    for (let i = state.particles.length - 1; i >= 0; i--){
      const p = state.particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.15, dt);
      p.vy *= Math.pow(0.15, dt);
      p.t += dt;
      if (p.t >= p.life) state.particles.splice(i, 1);
    }

    for (let i = state.shells.length - 1; i >= 0; i--){
      const s = state.shells[i];
      const sr = shellRadiusForCollision(s.r);

      let hitIndex = -1;
      for (let j = state.bullets.length - 1; j >= 0; j--){
        const b = state.bullets[j];
        if (Math.hypot(b.x - s.x, b.y - s.y) < sr + b.r){
          hitIndex = j;
          break;
        }
      }
      if (hitIndex !== -1){
        state.bullets.splice(hitIndex, 1);
        state.shells.splice(i, 1);
        splitShell(s);
      }
    }

    if (ship.alive){
      for (const s of state.shells){
        const sr = shellRadiusForCollision(s.r);
        if (Math.hypot(ship.x - s.x, ship.y - s.y) < sr + ship.r*0.9){
          killShip();
          break;
        }
      }
    }

    if (state.shells.length === 0){
      state.wave += 1;
      waveEl.textContent = state.wave;
      spawnWave(state.wave);
    }

    clear();
    drawShells();
    drawBullets();
    drawShip();
    drawParticles(dt);

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = 'rgba(233,238,247,0.30)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(W/2, H/2, Math.min(W,H)*0.38, 0, TAU);
    ctx.stroke();
    ctx.restore();
  }

  // ---------- Overlay / flow ----------
  function showOverlay(title, descHTML, canRestart){
    titleEl.textContent = title;
    descEl.innerHTML = descHTML;

    overlay.style.display = 'grid';
    startBtn.style.display = state.wave === 1 && state.score === 0 && state.lives === 3 ? '' : 'none';
    resumeBtn.style.display = (!state.over && input.paused) ? '' : 'none';
    restartBtn.style.display = canRestart ? '' : 'none';
  }

  function hideOverlay(){
    overlay.style.display = 'none';
  }

  function startGame(){
    state.running = true;
    state.over = false;
    input.paused = false;
    state.wave = 1;
    state.score = 0;
    state.lives = 3;
    scoreEl.textContent = '0';
    livesEl.textContent = '3';
    waveEl.textContent = '1';
    spawnWave(1);
    hideOverlay();
  }

  startBtn.addEventListener('click', () => startGame());
  resumeBtn.addEventListener('click', () => { input.paused = false; hideOverlay(); });
  restartBtn.addEventListener('click', () => startGame());

  document.addEventListener('visibilitychange', () => {
    if (document.hidden && state.running && !state.over){
      input.paused = true;
      showOverlay('Paused', 'Game paused when the tab went to the background.', false);
      startBtn.style.display = 'none';
      resumeBtn.style.display = '';
      restartBtn.style.display = '';
    }
  });

  const ro = new ResizeObserver(() => {
    resize();
    initStars();
  });
  ro.observe(canvas);

  showOverlay('Pasta Shells', 'Tap <b>Start</b>. On iPhone, use the buttons below (Left, Right, Thrust, Shoot).', true);

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
